extern crate wgsl_to_wgpu;

use std::fmt::Write;
use wgsl_to_wgpu::{create_shader_modules, MatrixVectorTypes, WriteOptions};

fn generate_wgsl_source_string() -> String {
    String::new()
}
fn demangle(name: &str) -> wgsl_to_wgpu::TypePath {
    wgsl_to_wgpu::demangle_identity(name)
}
fn main() -> Result<(), Box<dyn std::error::Error>> {
    const SHADER_BASE: &str = "shaders";
    const BINDING_BASE: &str = "src";

    // Read all .wgsl files from the shader directory
    for entry in std::fs::read_dir(SHADER_BASE)? {
        let entry = entry?;
        let path = entry.path();

        if path.extension() == Some("wgsl".as_ref()) {
            let name = path.file_stem().unwrap().to_str().unwrap();
            let wgsl_source = std::fs::read_to_string(&path)?;

            // Generate the Rust bindings and write to a file.
            let mut text = String::new();
            writeln!(&mut text, "// File automatically generated by build.rs.")?;
            writeln!(&mut text, "// Changes made to this file will not be saved.")?;

            text += &create_shader_modules(
                &wgsl_source,
                // &path.to_str().unwrap(),
                WriteOptions {
                    derive_bytemuck_vertex: true,
                    derive_bytemuck_host_shareable: true,
                    derive_encase_host_shareable: true,
                    matrix_vector_types: MatrixVectorTypes::Glam,
                    rustfmt: true,
                    validate: Some(Default::default()),
                    ..Default::default()
                },
                demangle,
            )
            .inspect_err(|error| error.emit_to_stderr_with_path(&wgsl_source, &path))
            .map_err(|_| "Failed to validate shader")?;

            std::fs::write(format!("{BINDING_BASE}/{name}.rs"), text.as_bytes())?;

            // Tell Cargo to rerun this script if the shader file changes
            // println!("cargo:rerun-if-changed={}", path.display());
        }
    }

    Ok(())
}
